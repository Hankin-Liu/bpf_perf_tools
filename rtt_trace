#!/usr/bin/python3
#################################################################################################################
# rtt_trace   Trace rtt for udp packages
#
# Dependencies: scapy
# Platform: linux
#
#usage: rtt_trace [-h] [-m MIN_TRACE_TIME] [-f FILTER]
# Run " rtt_trace -h" for detail.
#
# Copyright (c) 2023 Hankin.
# Licensed under the Apache License, Version 2.0 (the "License")
#
# 11-Dec-2023   Hankin       Created this.
#################################################################################################################

import argparse
import configparser
from scapy.all import *

UNSET_PORT = -1
UNSET_IP = "-1"
rtt_dict = {}

examples = """examples:
            ./rtt_trace -m 1000 # trace rtt which >= 1ms
            ./rtt_trace -f "udp and (src host 5000 or dst port 5100)" # trace rtt for udp which source host is 5000 or destination port is 5100
            """
parser = argparse.ArgumentParser(
    description = "trace rtt latency for udp packages",
    formatter_class = argparse.RawDescriptionHelpFormatter,
    epilog = examples)
parser.add_argument("-m", "--min_trace_time", default=0, type=int,
                    help="the rtt in microseconds over which we store traces")
parser.add_argument("-f", "--filter", type = str, default="", help = "specify a filter rule.")
args = parser.parse_args()
rtt_threshold_s = float(args.min_trace_time) / 1000 / 1000
#print(args.filter)

config = configparser.ConfigParser()
config.read('./rtt_trace.ini')
pkg_type_offset_for_begin = config.getint('rtt_begin', 'pkg_type_offset')
pkg_type_size_for_begin = config.getint('rtt_begin', 'pkg_type_size')
pkg_type_value_for_begin = config.getint('rtt_begin', 'pkg_type_value')
match_arg_count = config.getint('rtt_begin', 'match_arg_count')
match_args_offset_for_begin = []
match_args_size_for_begin = []
for i in range(1, match_arg_count + 1):
    key_offset = "match_arg%d_offset" % i
    offset = config.getint('rtt_begin', key_offset)
    match_args_offset_for_begin.append(offset)
    key_size = "match_arg%d_size" % i
    size = config.getint('rtt_begin', key_size)
    match_args_size_for_begin.append(size)
    begin_dst_port = config.getint('rtt_begin', 'dst_port')
    begin_dst_ip = config['rtt_begin']['dst_ip']
    begin_src_port = config.getint('rtt_begin', 'src_port')
    begin_src_ip = config['rtt_begin']['src_ip']
    pkg_type_offset_for_end = config.getint('rtt_end', 'pkg_type_offset')
    pkg_type_size_for_end = config.getint('rtt_end', 'pkg_type_size')
    pkg_type_value_for_end = config.getint('rtt_end', 'pkg_type_value')
    match_args_offset_for_end = []
    match_args_size_for_end = []
    for i in range(1, match_arg_count + 1):
        key_offset = "match_arg%d_offset" % i
        offset = config.getint('rtt_end', key_offset)
        match_args_offset_for_end.append(offset)
        key_size = "match_arg%d_size" % i
        size = config.getint('rtt_end', key_size)
        match_args_size_for_end.append(size)
        end_dst_port = config.getint('rtt_end', 'dst_port')
        end_dst_ip = config['rtt_end']['dst_ip']
        end_src_port = config.getint('rtt_end', 'src_port')
        end_src_ip = config['rtt_end']['src_ip']

def change_time(pkgtime):
    ts = time.strftime('%Y-%m-%d-%X', time.localtime(int(pkgtime)))
    ms = (pkgtime - int(pkgtime)) * 1000000
    time_ms = '%s.%.0f' % (ts, ms)
    return time_ms

def is_rtt_begin(packet):
    if begin_dst_port != UNSET_PORT and packet[UDP].dport != begin_dst_port:
        return False
    if begin_src_port != UNSET_PORT and packet[UDP].sport != begin_src_port:
        return False
    if begin_dst_ip != UNSET_IP and packet[UDP].dst != begin_dst_ip:
        return False
    if begin_src_ip != UNSET_IP and packet[UDP].src != begin_src_ip:
        return False
    return True

def is_rtt_end(packet):
    if end_dst_port != UNSET_PORT and packet[UDP].dport != end_dst_port:
        return False
    if end_src_port != UNSET_PORT and packet[UDP].sport != end_src_port:
        return False
    if end_dst_ip != UNSET_IP and packet[UDP].dst != end_dst_ip:
        return False
    if end_src_ip != UNSET_IP and packet[UDP].src != end_src_ip:
        return False
    return True

def packet_callback(packet):
    if is_rtt_begin(packet):
        data_len = len(packet['Raw'].load)
        if data_len < pkg_type_offset_for_begin + pkg_type_size_for_begin:
            return
        type_value = int.from_bytes(packet['Raw'].load[pkg_type_offset_for_begin:pkg_type_offset_for_begin + pkg_type_size_for_begin], byteorder='little')
        if pkg_type_value_for_begin == type_value:
            rtt_key = []
            for i in range(0, match_arg_count):
                offset = match_args_offset_for_begin[i]
                size = match_args_size_for_begin[i]
                if data_len < offset + size:
                    return
                rtt_key.append(int.from_bytes(packet['Raw'].load[offset:offset + size], byteorder='little'))
            rtt_dict[tuple(rtt_key)] = packet.time
    elif is_rtt_end(packet):
        data_len = len(packet['Raw'])
        if data_len < pkg_type_offset_for_end + pkg_type_size_for_end:
            return
        type_value = int.from_bytes(packet['Raw'].load[pkg_type_offset_for_end:pkg_type_offset_for_end + pkg_type_size_for_end], byteorder='little')
        if pkg_type_value_for_end == type_value:
            rtt_key = []
            for i in range(0, match_arg_count):
                offset = match_args_offset_for_end[i]
                size = match_args_size_for_end[i]
                if data_len < offset + size:
                    return
                rtt_key.append(int.from_bytes(packet['Raw'].load[offset:offset + size], byteorder='little'))
            start_time = rtt_dict.pop(tuple(rtt_key), None)
            if start_time is not None:
                duration = packet.time - start_time
                if duration > rtt_threshold_s:
                    print("Time = [%-26s], rtt = [%f]s, key = " % (change_time(packet.time), duration), end="")
                    print(rtt_key)

#construct filter rule begin
custom_filter = "udp "
tmp_begin = ""
if begin_dst_port != UNSET_PORT:
    tmp_begin += "dst port %s " % begin_dst_port
if begin_dst_ip != UNSET_IP:
    if tmp_begin != "":
        tmp_begin += "and "
    tmp_begin += "dst host %s " % begin_dst_ip
if begin_src_port != UNSET_PORT:
    if tmp_begin != "":
        tmp_begin += "and "
    tmp_begin += "src port %s " % begin_src_port
if begin_src_ip != UNSET_IP:
    if tmp_begin != "":
        tmp_begin += "and "
    tmp_begin += "src host %s " % begin_src_ip

tmp_end = ""
if end_dst_port != UNSET_PORT:
    tmp_end += "dst port %s " % end_dst_port
if end_dst_ip != UNSET_IP:
    if tmp_end != "":
        tmp_end += "and "
    tmp_end += "dst host %s " % end_dst_ip
if end_src_port != UNSET_PORT:
    if tmp_end != "":
        tmp_end += "and "
    tmp_end += "src port %s " % end_src_port
if end_src_ip != UNSET_IP:
    if tmp_end != "":
        tmp_end += "and "
    tmp_end += "src host %s " % end_src_ip

if tmp_begin != "" and tmp_end != "":
    custom_filter += "and ((" + tmp_begin + ") or (" + tmp_end + "))"
elif tmp_begin != "":
    custom_filter += "and (" + tmp_begin + ")"
elif tmp_end != "":
    custom_filter += "and (" + tmp_end + ")"
#construct filter rule end

#if filter is specified by command line
if args.filter != "":
    custom_filter = args.filter

sniff(filter=custom_filter, prn=packet_callback)
